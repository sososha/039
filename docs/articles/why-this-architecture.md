# 🚧 なぜこのアーキテクチャに至ったのか  
### ― OCCT, wgpu, Rust の狭間で悩んだ記録 ―

これは「完成した仕様書」ではなく、  
**この設計に辿り着くまでのプロセスと判断基準**を記録したドキュメントです。

同じ問いに直面する未来の開発者やAI（そして過去の自分）へのメモです。

---

## 🥇 最初の候補: OCCT + AIS + OpenGL

最初は OpenCascade (OCCT) を中心に据える案が最有力でした。

- AIS（Application Interactive Services）は  
  CADとして必要な可視化・ハイライト・選択・寸法・ピックをすべて持っている。
- Shape/BRepカーネルとして歴史・実績・信頼性が圧倒的。
- FreeCADやSolidWorksと同系統のアーキテクチャ。

👉 **しかし決定的な問題:**  
**AISが OpenGL に深く依存している。**

> WebGPU 時代に、OpenGL “前提” の描画モデルを未来へ持ち込むのは厳しい。

- モバイル / Web / Metal / Vulkan / D3D12 への移行が困難
- レンダリングパイプラインが固定されすぎている
- 「モダングラフィックスの設計思想」と噛み合わない

結論:  
**OCCTは参考にするが、そのままは使わない。  
特に AIS は“模倣対象”ではなく“分解すべき思想の塊”。**

---

## 🥈 次の候補: RustネイティブCADフレームワーク（Truck など）

Rust製というだけで魅力的でしたが、

- tessellation が主である
- 表示・状態管理・ハイライト・選択・Undo/Redo といったCAD UXの必須部分が存在しない

👉 結論:

> 「Truck は部品として利用できるが **アーキテクチャとしては不足**」

---

## 🥉 UIフレームワーク側でやる案（Qt/Floem/GUI層統合）

一時期 Floem + commands 方式や Qt 的構造に寄せる案も検討しました。しかし:

- GUIフレームワークに依存したCADコマンド・選択モデルは **長期的に腐る**
- AAA CADの歴史では「GUIとCADエンジンは分離する」が定石

👉 結論:

> UIは交換可能、CADコアとRendererが中心。  
> **UIは消えても SceneContext が残る設計にする。**

---

## 💡 最終到達点: Rust + wgpu + ECS + Dirty-driven Rendering

この選択は「理想」ではなく、**制約と未来性から逆算した結果**です。

| 要素 | 採用理由 |
|------|---------|
| **Rust** | 長寿命コード・安全性・並列処理・AI補完相性 |
| **wgpu/WebGPU** | OpenGL の終焉。Native/Web/Mobile 対応。将来性。 |
| **ECS** | 状態遷移・Undo/Redo・拡張可能性との相性が良い |
| **Dirty-driven sync** | 描画更新の抜け漏れ禁止。CAD 特有の「更新順序の厳密さ」に対応。 |
| **SceneContext API** | “誤用を防ぐ表面”が必要。内部は危険でも外は安全。 |

---

## 🎯 この設計のゴール

> **「壊れにくいCADを、AIが触っても壊れない構造で作る。」**

- README や思想ではなく、**型・visibility・API契約で安全性を担保**
- レンダリングは「結果の反映役」  
  → モデルの真実は CAD コアにある
- コマンドは FSM で表現し、曖昧さ・暗黙処理を排除

---

## 🧬 原則（Philosophy）

```text
・禁止できるバグは構造で禁止する
・曖昧な仕様は将来必ずバグになる
・レンダリングは忠実な鏡であり、意思決定の場所ではない
・Undo/Redoできない状態変更は存在してはいけない
・“UI依存”の仕様は未来の足枷になる
```

---

## 🏁 結論

OCCT や AIS の「経験値」は尊敬しています。  
しかしその設計は **OpenGL 世代の最適解** であり、今作るべきは:

> **WebGPU 世代の CAD Kernel + Visual Engine**

です。

この文書は、その「世代交代」を設計思想として残すために存在します。

---

👋 **未来へ向けて。**

